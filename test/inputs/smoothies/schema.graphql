# -------------------------------------------------
# Global directives used by the codeâ€‘generator
# -------------------------------------------------

directive @compute(fn: String, expr: String) on FIELD_DEFINITION
directive @expand(into: String!) on FIELD_DEFINITION | OBJECT
directive @method(expr: String, fn: String) on FIELD_DEFINITION
directive @default(expr: String!) on FIELD_DEFINITION
directive @static_method(name: String!, expr: String!) repeatable on OBJECT

# -------------------------------------------------
# Scalars and Enums  
# -------------------------------------------------

scalar String
scalar Float
scalar CaloriesPerGram

enum Size {
  SMALL
  MEDIUM
  LARGE
}

# -------------------------------------------------
# Basic Types
# -------------------------------------------------

type NutritionalInfo {
  calories_per_gram: Float!
  protein_grams: Float!
  sugar_grams: Float!
  fiber_grams: Float!
}


# -------------------------------------------------
# Interfaces
# -------------------------------------------------


interface Ingredient {
  name: String!
  calories_per_gram: Float
}


type Fruit implements Ingredient {
  name: String!
  calories_per_gram: Float!
  sweetness: Float!
}

type Addon implements Ingredient {
  name: String!
  calories_per_gram: Float!
  protein: Float!
}

# -------------------------------------------------
# Unions
# -------------------------------------------------

union Blendable = Fruit | Addon

# -------------------------------------------------
# Main Types  
# -------------------------------------------------

"""Demo: show @default in action"""
type ScalarHolder {
  value: Float! @default(expr: "3.141592")
}

"""Demo: show @static_method factory"""
type SmoothieFactory
  @static_method(
    name: "empty_small",
    expr: "Smoothie(name='Empty', size=Size.SMALL, parts=[])"
  )
{
  dummy: String  # no real fields needed
}

type IngredientAmount {
  ingredient: Blendable!
  grams: Float!
  calories: Float! @compute(fn: "calcCalories")
}

type Smoothie {
  name: String!
  size: Size!
  parts: [IngredientAmount!]!

  # Already-existing computed field
  fruit_names: [String!]!
    @compute(expr:"parts[is Fruit].ingredient.name")

  # example of using @method to expose a computed field as a method
  get_fruit_names: [String!]!
    @method(expr:"parts[is Fruit].ingredient.name")
}

type BananaStrawberrySmoothie {
  # Parameters ----------
  size: Size!

  # Expansion spec ------
  result: Smoothie!
    @expand(
      into: """
      {
        "name": "Banana-Strawberry",
        "size": "$size",
        "parts": [
          {
            "ingredient": {"name": "Banana", "calories_per_gram": 0.89, "sweetness": 8.5},
            "grams": 120
          },
          {
            "ingredient": {"name": "Strawberry", "calories_per_gram": 0.32, "sweetness": 7.2},
            "grams": 80
          },
          {
            "ingredient": {"name": "Protein Powder", "calories_per_gram": 4.0, "protein": 25.0},
            "grams": 30
          }
        ]
      }
      """
    )
}
