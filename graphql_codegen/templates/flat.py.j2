from __future__ import annotations
from typing import List, Optional, Any, Dict, Union
from pydantic import BaseModel, Field
from enum import Enum
{%- if additional_imports %}
{%- for import_line in additional_imports %}
{{ import_line }}
{%- endfor %}
{%- endif %}
import json

# Auto-generated helpers - inline
_COMPUTE: Dict[str, Any] = {}
_EXPAND_CUSTOM: Dict[str, Any] = {}

{% if needs_computable_import %}
class Computable:
    """Mixin for types with @compute fields."""
    def compute(self, field_name: str) -> Any:
        """Compute value for field with @compute directive."""
        if not hasattr(self.__class__, "model_fields"):
            raise TypeError(f"{self.__class__.__name__} is not a Pydantic model, cannot use Computable.")
        fld = self.__class__.model_fields.get(field_name)
        if not fld:
            raise ValueError(f"Field '{field_name}' not found in model {self.__class__.__name__}.")
        meta = fld.json_schema_extra or {}
        compute_meta = meta.get("compute")
        if not compute_meta or not isinstance(compute_meta, dict):
            raise ValueError(f"Field '{field_name}' in model {self.__class__.__name__} has no valid @compute metadata.")
        fn_name = compute_meta.get("fn")
        if not fn_name:
            raise ValueError(f"Compute metadata for '{field_name}' is missing 'fn'.")
        return _COMPUTE[fn_name](self, field_name, compute_meta)
{% endif %}

{% if needs_expandable_import %}
class Expandable:
    """Mixin for types with @expand directive."""
    def expand(self) -> Any:
        """Expand this node into primitive components."""
        # Simplified expand implementation for flat output
        return self
{% endif %}

# Registration functions
def register_compute_fn(name: str):
    def _wrap(fn):
        _COMPUTE[name] = fn
        return fn
    return _wrap

def register_expand_fn(name: str):
    def _wrap(fn):
        _EXPAND_CUSTOM[name] = fn
        return fn
    return _wrap

{%- for enum_info in enums %}

class {{ enum_info.name }}(str, Enum):
    """Generated from GraphQL enum {{ enum_info.name }}."""
{%- for value in enum_info.values %}
    {{ value }} = "{{ value }}"
{%- endfor %}
{%- endfor %}

{%- for type_info in types %}
{%- if type_info.kind != "union" %}

class {{ type_info.name }}({{ type_info.base_classes | join(", ") }}):
    """Generated from GraphQL {{ type_info.kind }} {{ type_info.name }}."""
{%- for field in type_info.fields %}
    {{ field.name }}: {{ field.python_type }} = Field({% if field.python_type.startswith("Optional[") %}default=None{% else %}...{% endif %}{% if field.json_schema_extra %}, json_schema_extra={{ field.json_schema_extra | repr }}{% endif %})
{%- endfor %}
{%- if type_info.expansion_spec %}
{{ type_info.expansion_spec }}
{%- endif %}
    model_config = {"protected_namespaces": ()}  # Pydantic v2 config
{%- endif %}
{%- endfor %}

# Union type aliases
{%- for type_info in types %}
{%- if type_info.kind == "union" %}
{{ type_info.name }} = Union[{% for union_type in type_info.union_types %}"{{ union_type }}"{% if not loop.last %}, {% endif %}{% endfor %}]
{%- endif %}
{%- endfor %}

# Rebuild models to resolve forward references and inheritance
{%- for type_info in types %}
{%- if type_info.kind != "union" %}
{{ type_info.name }}.model_rebuild()
{%- endif %}
{%- endfor %} 